# TIMESTAMP EXAMPLES FOR START/UNTIL INTERVALS
# Monthly resolution: 2019-05-01
#   --> Includes data from2019-05-01 00:00 UTC to 2019-05-31 23:59 UTC (i.e. May 2019)
# Weekly resolution: 2019-05-13
#   -->  Includes data from 2019-05-13 00:00 UTC to 2019-05-19 23:59 UTC (i.e. Week 20)
# Daily resolution: 2019-05-13
#   --> Includes data from2019-05-13 00:00 UTC to 2019-05-13 23:59 UTC
# Hourly resolution: 2019-05-13 10:00 UTC
#   --> Includes data from2019-05-13 10:00 UTC to 2019-05-13 10:59 UTC
# 10 Min resolution: 2019-05-13 10:20 UTC
#   --> Includes data from 2019-05-13 10:20 UTC to 2019-05-13 10:29 UTC

import os
import logging
import json
from datetime import datetime
from queue import Queue
from _queue import Empty
from threading import Thread, Event, Condition, RLock
from collections import defaultdict
from typing import Any, Optional, Dict, Tuple, List, Sequence

import pandas
import ciso8601
from requests import Request, Session, Response
from pprint import pprint
from dotenv import load_dotenv, find_dotenv

load_dotenv(find_dotenv())
logging.basicConfig(level=logging.DEBUG, format='(%(threadName)-9s) %(message)s')


__all__ = [
    'GlassBroker',
    'GlassClient',
    'GlassHandler',
    'defaultdict',
    'datetime',
    'logging',
    'pprint',
    'pandas',
    'json',
    'Optional',
    'Tuple',
    'Dict',
    'Any'
]


class GlassBroker:
    _GLASSNODE = "https://api.glassnode.com/v1/metrics"
    _HELPER = "https://api.glassnode.com/v2/metrics/endpoints"
    _API_KEY = os.getenv('GLASSNODE')

    def __init__(self):
        self._validity = self._load_valid_endpoints()
        self._session = Session()

    @staticmethod
    def _load_valid_endpoints() -> Dict:
        with open(file='ENDPOINTS.json', mode='r') as _check_valid:
            return json.loads(_check_valid.readline())

    @staticmethod
    def _process_response(index_path: str, asset: str, response: Response) -> Tuple:
        """ Base-Handler; all responses pass through this method, _PRIVATE. """
        logging.debug(
            f'<Response[ {response.status_code} : {response.reason} : {datetime.now()}]>\n')
        assert response.status_code is 200, \
            f'Error:[{response.status_code}:{response.reason}]\n{response.request}\n{response.headers}'
        return f'{index_path.upper()}_{asset}', response

    def _request(self, req_method: str, target: str, params: Optional[Dict[str, Any]] = None) -> Tuple:
        """
        <GET> only method currently implemented. Handles all request.methods, I think?

        :param req_method: HTTP request method. Default(<GET>)
        :param target: Full api request endpoint. **constructed by caller
        :param params: Asset('a') required, all others autogenerated where needed

        :return: dict(key=request_endpoint, value=[asset_name, response.json])
        """
        params['api_key'] = self._API_KEY
        assert 'a' and 'api_key' in params, "MinParams=('asset'+'api_key') you fucking donkey"
        response = self._session.send(
            Request(method=req_method, url=target, params=params).prepare())
        response.close()
        return self._process_response('/'.join(target.split('/')[-2:]), params['a'], response)

    def get_metrics(self, index: str, endpoint: str, **kwargs):  # -> Tuple[str, Response]:
        """
        GET/Query -> https://api.glassnode.com/v1/metrics/<user>
        See GlassClient.glass_quest docstring for all possible kwargs

        :param index: API endpoint, ex; index='indicators'
        :param endpoint: API endpoint, ex; endpoint='stock_to_flow_ratio'
        :param kwargs: {'a': AssetSymbol(required)}

        :return: tuple('index_endpoint_asset', Response)
        """
        assert endpoint in self._validity[index], f'Need valid endpoint you fucking donkey\n{endpoint}'
        _path = f'{self._GLASSNODE}/{index}/{endpoint}'
        return self._request('GET', target=_path, params=kwargs)

    def get_endpoints(self, path=True, tier=False, assets=False):
        """
        Query all known glassnode endpoints and their optional parameters
        Internals are absolute heavy wizardry, see the raw response obj for clarity

        :param path: Get endpoint *omitting glassnode.api prefix
        :param tier: Get subscription tier required for unrestricted calls
        :param assets: Get available assets for given endpoint

        :return: None, prints results
        """
        locals_copy = locals().copy()
        del locals_copy['self']
        requested, response = self._request('GET', target=self._HELPER, params={'a': '_null_helper'})
        response = response.json()
        return [[([sym['symbol'] for sym in end_pt[query]] if query in 'assets'
                  else (end_pt[query] if query in 'tier'
                        else '/'.join(end_pt['path'].split('/')[-2:])))
                 for query in filter(lambda x: locals_copy[x] is not False, locals_copy)]
                for end_pt in response]


class GlassClient(GlassBroker):
    """
    * Parameters can be passed to class call or instance method.

    * Attributes stored across instances for easy subsequent requests.

    * See GlassClient.glass_quest docstring for parameter details.

    * REQUIRED -> index: str, endpoint: str, asset_symbol['a']: str.

    * OPTIONAL -> kwargs: defaults applied on instance creation.

    * METRIC-TIMESTAMPS(utc) -> Always refer to start of interval.
    """

    _PATH, _PARAMS = ['index', 'endpoint'], ['a', 's', 'u', 'i', 'f', 'c', 'e', 'timestamp_format']

    def __init__(self, index=None, endpoint=None,
                 a=None, s=None, u=None, i='24h', f='JSON',
                 c=None, e=None, timestamp_format='unix'):
        super(GlassClient, self).__init__()
        self.a = a
        self.s = s
        self.u = u
        self.i = i
        self.f = f
        self.c = c
        self.e = e
        self.timestamp_format = timestamp_format
        self.index = index
        self.endpoint = endpoint
        self.params = \
            {k: (ciso8601.parse_datetime(ve).strftime('%Y-%m-%d %H:%M') if k in ('s', 'u') else ve)
             for k, ve in locals().copy().items() if (k in self._PARAMS and ve is not None)}

    def _set_attributes(self, **kwargs):
        """ Class attributes setter_handler. _PRIVATE """
        for pos_key, pos_val in kwargs.items():
            if pos_key in 'kwargs':
                foo_copy = getattr(self, 'params').copy()
                for kwarg_key, kwarg_val in kwargs[pos_key].items():
                    foo_copy[kwarg_key] = kwarg_val
                setattr(self, 'params', foo_copy)
            else:
                setattr(self, pos_key, pos_val)

    def glass_quest(self, index: str = None, endpoint: str = None, **kwargs):
        """
        See 'GlassClient.endpoint_helper' for available endpoints.

        * "index": str = ex.'indicators'
        * "endpoint": str = ex.'hash_ribbon'
        * "a": str = ex.'BTC'
        * "s": int = ISO-8601:[YYYY-MM-DD HH:MM]
        * "u": int = ISO-8601:[YYYY-MM-DD HH:MM]
        * "i": str = freq_interval(['1h', '24h', '10m', '1w', '1month'])
        * "f": str = format(['JSON', 'CSV'])
        * "c": str = currency(['NATIVE', 'USD'])
        * "e": str = ['aggregated','binance','bittrex','coinex','gate.io','huobi','poloniex']
        * "timestamp_format": str = 'unix'.try('humanized(RFC-3339)')
        * "api_key": str = autofill(see_base_class_attrs)

        :return: tuple('index_endpoint_asset', Response)
        """
        qc = locals().copy()
        if index and endpoint is not None:
            self._set_attributes(index=qc['index'], endpoint=qc['endpoint'])
        if len(qc['kwargs']) != 0:
            self._set_attributes(kwargs=qc['kwargs'])
        assert self.index and self.endpoint and self.params['a'] is not None, \
            "U fucking donkey! REQUIRED ATTRIBUTES are required at some point!!!"
        return self.get_metrics(
            getattr(self, 'index'), getattr(self, 'endpoint'), **getattr(self, 'params'))


class GlassHandler(GlassClient):
    # Pandas DataFrame Configuration
    pandas.set_option('display.width', 120)

    def __init__(self):
        super(GlassHandler, self).__init__()
        self._arbiter = Thread(name='_ARBITER_', target=self._queue_arbiter)
        self._request_events = Event()
        self._response_events = Event()
        self._ready_plotter = Event()
        self._responses = Queue()
        self._processed = []

    @staticmethod
    def print_processed(ready) -> None:
        """ DataFrame pretty printer """
        _fat_line = ''.join(['-' for i in range(50)])
        try:
            print("\n{}\nDataFrame: -> {}\n\n{}\n\n{}\n{}".format(
                _fat_line, ready.name, ready, ready.describe(), _fat_line))
        except AttributeError:
            for dp in ready:
                print("\n{}\nDataFrame: -> {}\n\n{}\n\n{}\n{}".format(
                    _fat_line, dp.name, dp, dp.describe(), _fat_line))

    @staticmethod
    def _reader_writer(meter, dater=None) -> Any:
        """  If a metric has been previously saved load save, else request metric """
        _metric = '_'.join(meter.split('/')).upper()
        if dater:
            with open(file=f"GET_REKT/{_metric}.json", mode='w') as filer:
                filer.write(dater.text)
        else:
            with open(file=f"GET_REKT/{_metric}.json", mode='r') as filer:
                return json.loads(filer.readline())

    def json_to_df(self, _metric, _data):
        # TODO timeit (git_implementation) vs (my_implementation)
        #  * df = pd.DataFrame(json.loads(r.text))
        #  * df = df.set_index('t')
        #  * df.index = pd.to_datetime(df.index, unit='s')
        #  * df = df.sort_index()
        #  * s = df.v
        #  * s.name = '_'.join(url.split('/')[-2:])
        #  * return s
        try:
            frame_keys = ['t'] + list(_data[0]['o'].keys())
            framed = pandas.DataFrame(
                data=[{k: (_data[iters]['t'] if k in 't' else _data[iters]['o'][k])
                       for k in frame_keys} for iters in range(len(_data))],
                columns=frame_keys)
        except KeyError:
            framed = pandas.DataFrame(_data)
        framed.set_index('t', inplace=True)
        framed.index = pandas.to_datetime(
            framed.index.to_flat_index(), unit='s', infer_datetime_format=True)
        framed.sort_index(inplace=True)
        framed.name = _metric
        self.print_processed(framed)  # Prints DataFrames
        self._processed.append(framed)

    def _queue_arbiter(self):
        """ Response queue get method; threads RawResponse -> DataFrame task """
        while True:
            try:
                _metric, _data = self._responses.get(timeout=1)
                self._reader_writer(_metric, _data)
                thread_json = Thread(target=self.json_to_df, args=(_metric, _data.json()))
                thread_json.start()
                self._responses.task_done()
            except Empty:
                logging.debug(f"Q.Empty -> {self._responses.qsize()}")
                self._ready_plotter.set()
                break

    def _q_request(self, index: str, endpoint: str, **kwargs) -> None:
        """ Sends HTTP request to glassnode and puts raw response obj in FIFO queue """
        metric, data = self.glass_quest(index=index, endpoint=endpoint, **kwargs)
        self._responses.put([metric, data])
        self._request_events.set()

    def magic_metrics(self, queries: List[Tuple[str, str, Dict[str, Any]]], update=False) -> List:
        """ U.I. Layer, pass Tuple['idx', 'endpoint', Dict:[str(param), Any]] """
        requesting = False
        for idx, ends, kwargs in queries:
            _target = f"{idx}_{ends}_{kwargs['a']}"
            try:
                if update:
                    raise OSError
                logging.debug('>>> TRY BLOCK. . .')
                arg_tup = _target, self._reader_writer(_target)
                json_frame = Thread(
                    name=_target, target=self.json_to_df, args=(*arg_tup,), daemon=True)
                json_frame.start()
            except OSError:
                _requester = Thread(
                    name=_target, target=self._q_request, args=(idx, ends), kwargs=kwargs, daemon=True)
                _requester.start()
                requesting = True
        if requesting:
            logging.debug('>>> WAIT -> _request.response_event. . .')
            self._request_events.wait(timeout=4)
        self._arbiter.start()
        self._ready_plotter.wait(timeout=4)
        return self._processed


def quick_helper(p=True, t=False, a=False) -> None:
    _quick_help = GlassBroker()
    for glassy in _quick_help.get_endpoints(path=p, tier=t, assets=a):
        print(glassy)


if __name__ == '__main__':
    logging.debug(f'>>> Initialized __ApeQuest__ as {__name__}\n')
    # meters = (('market', 'price_usd_close', {'a': 'BTC'}),)
    # foos = GlassHandler()
    # foobars = foos.magic_metrics(meters)


else:
    logging.debug(f'>>> Initialized __ApeQuest__ as {__name__}\n')


# TODO Why are below metrics restricted(status:403)?
#   * ('market', 'mvrv_less_155', {'a': "BTC"}),
#   * ('market', 'mvrv_more_155', {'a': "BTC"}),

# class MongoServer:
#     def __init__(self):
#         pass
# TODO Create Mongo class + identifiers of sorts(maybe file handler?)
#   * Collection/Document Header -> Last Update Datetime
#   * JSON/BSON fields
# class MongoClient(MongoBroker):
#     def __init__(self):
#         super(MongoClient, self).__init__()

# _non_standard_responses = (
#     'futures_funding_rate_perpetual_all',
#     'futures_volume_daily_sum_all',
#     'futures_volume_daily_perpetual_sum_all',
#     'futures_open_interest_sum_all',
#     'futures_open_interest_perpetual_sum_all',
#     'futures_open_interest_latest',
#     'futures_volume_daily_latest',
#     'balance_exchanges_all',
#     'balance_miners_all',
#     'supply_distribution_relative',
#     'exchanges_sum',
#     'exchanges_relative',
#     'exchanges_mean',
#     'hash_ribbon',
#     'difficulty_ribbon',
#     'spent_output_price_distribution_ath',
#     'spent_output_price_distribution_percent',
#     'cyd',
#     'cyd_supply_adjusted',
#     'cyd_account_based_supply_adjusted',
#     'cyd_account_based', 'cdd90_age_adjusted',
#     'cdd90_account_based_age_adjusted',
#     'stock_to_flow_ratio',
#     'utxo_realized_price_distribution_ath',
#     'utxo_realized_price_distribution_percent',
#     'soab',
#     'price_usd_ohlc',
#     'liquid_illiquid_sum',
#     'hodl_waves',
#     'rcap_hodl_waves',
#     'lth_sth_profit_loss_relative',
#     'transfers_volume_miners_to_exchanges_all',
#     'supply_distribution_relative'
# )
