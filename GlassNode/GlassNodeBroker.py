# TIMESTAMP EXAMPLES FOR START/UNTIL INTERVALS
# Monthly resolution: 2019-05-01
#   --> Includes data from2019-05-01 00:00 UTC to 2019-05-31 23:59 UTC (i.e. May 2019)
# Weekly resolution: 2019-05-13
#   -->  Includes data from 2019-05-13 00:00 UTC to 2019-05-19 23:59 UTC (i.e. Week 20)
# Daily resolution: 2019-05-13
#   --> Includes data from2019-05-13 00:00 UTC to 2019-05-13 23:59 UTC
# Hourly resolution: 2019-05-13 10:00 UTC
#   --> Includes data from2019-05-13 10:00 UTC to 2019-05-13 10:59 UTC
# 10 Min resolution: 2019-05-13 10:20 UTC
#   --> Includes data from 2019-05-13 10:20 UTC to 2019-05-13 10:29 UTC

import os
import logging
import json
from datetime import datetime
from queue import Queue
from _queue import Empty
from threading import Thread, Event, RLock
from collections import defaultdict
from typing import Any, Optional, Dict, Tuple, List  # , Sequence

import pandas
import ciso8601
from requests import Request, Session, Response
from pprint import pprint
from dotenv import load_dotenv, find_dotenv

load_dotenv(find_dotenv())
logging.basicConfig(level=logging.DEBUG, format='(%(threadName)-9s) %(message)s')


__all__ = [
    'GlassBroker',
    'GlassClient',
    'Glassnodes',
    'defaultdict',
    'datetime',
    'logging',
    'pprint',
    'pandas',
    'json',
    'Optional',
    'Tuple',
    'Dict',
    'List',
    'Any'
]


class GlassBroker:
    _GLASSNODE = "https://api.glassnode.com/v1/metrics"
    _HELPER = "https://api.glassnode.com/v2/metrics/endpoints"
    _API_KEY = os.getenv('GLASSNODE')

    def __init__(self):
        self._validity = self._load_valid_endpoints()
        self._session = Session()

    @staticmethod
    def _load_valid_endpoints() -> Dict:
        with open(file='ENDPOINTS.json', mode='r') as _check_valid:
            return json.loads(_check_valid.readline())

    @staticmethod
    def _process_response(index_path: str, asset: str, response: Response) -> Tuple:
        """ Base-Handler; all responses pass through this method, _PRIVATE. """
        logging.debug(
            f'<Response[ {response.status_code} : {response.reason} : {datetime.now()}]>\n')
        assert response.status_code is 200, \
            f'Error:[{response.status_code}:{response.reason}]\n{response.request}\n{response.headers}'
        return f'{index_path.upper()}_{asset}', response

    def _request(self, req_method: str, target: str, params: Optional[Dict[str, Any]] = None) -> Tuple:
        """
        <GET> only method currently implemented. Handles all request.methods, I think?

        :param req_method: HTTP request method. Default(<GET>)
        :param target: Full api request endpoint. **constructed by caller
        :param params: Asset('a') required, all others autogenerated where needed

        :return: dict(key=request_endpoint, value=[asset_name, response.json])
        """
        params['api_key'] = self._API_KEY
        assert 'a' and 'api_key' in params, "MinParams=('asset'+'api_key') you fucking donkey"
        response = self._session.send(
            Request(method=req_method, url=target, params=params).prepare())
        response.close()
        return self._process_response('/'.join(target.split('/')[-2:]), params['a'], response)

    def get_metrics(self, index: str, endpoint: str, **kwargs):  # -> Tuple[str, Response]:
        """
        GET/Query -> https://api.glassnode.com/v1/metrics/<user>
        See GlassClient.glass_quest docstring for all possible kwargs

        :param index: API endpoint, ex; index='indicators'
        :param endpoint: API endpoint, ex; endpoint='stock_to_flow_ratio'
        :param kwargs: {'a': AssetSymbol(required)}

        :return: tuple('index_endpoint_asset', Response)
        """
        assert endpoint in self._validity[index], f'{index}/{endpoint} -> Invalid u fucking donkey'
        _path = f'{self._GLASSNODE}/{index}/{endpoint}'
        return self._request('GET', target=_path, params=kwargs)

    def get_endpoints(self, path=True, tier=False, assets=False):
        """
        Query all known glassnode endpoints and their optional parameters
        Internals are absolute heavy wizardry, see the raw response obj for clarity

        :param path: Get endpoint *omitting glassnode.api prefix
        :param tier: Get subscription tier required for unrestricted calls
        :param assets: Get available assets for given endpoint

        :return: None, prints results
        """
        locals_copy = locals().copy()
        del locals_copy['self']
        requested, response = self._request('GET', target=self._HELPER, params={'a': '_null_helper'})
        response = response.json()
        return [[([sym['symbol'] for sym in end_pt[query]] if query in 'assets'
                  else (end_pt[query] if query in 'tier'
                        else '/'.join(end_pt['path'].split('/')[-2:])))
                 for query in filter(lambda x: locals_copy[x] is not False, locals_copy)]
                for end_pt in response]


class GlassClient(GlassBroker):
    """
    * Parameters can be passed to class call or instance method.

    * Attributes stored across instances for easy subsequent requests.

    * See GlassClient.glass_quest docstring for parameter details.

    * REQUIRED -> index: str, endpoint: str, asset_symbol['a']: str.

    * OPTIONAL -> kwargs: defaults applied on instance creation.

    * METRIC-TIMESTAMPS(utc) -> Always refer to start of interval.
    """

    _PATH, _PARAMS = ['index', 'endpoint'], ['a', 's', 'u', 'i', 'f', 'c', 'e', 'timestamp_format']

    def __init__(self, index=None, endpoint=None,
                 a=None, s=None, u=None, i='24h', f='JSON',
                 c=None, e=None, timestamp_format='unix'):
        super(GlassClient, self).__init__()
        self.a = a  # asset_symbol
        self.s = s  # start_point
        self.u = u  # until_point
        self.i = i  # resolution_interval
        self.f = f  # response_format
        self.c = c  # currency
        self.e = e  # exchange_name
        self.timestamp_format = timestamp_format
        self.index = index
        self.endpoint = endpoint
        self.params = \
            {k: (ciso8601.parse_datetime(ve).strftime('%Y-%m-%d %H:%M') if k in ('s', 'u') else ve)
             for k, ve in locals().copy().items() if (k in self._PARAMS and ve is not None)}

    def _set_attributes(self, **kwargs):
        """ Set class attributes. _PRIVATE """
        for pos_key, pos_val in kwargs.items():
            if pos_key in 'kwargs':
                foo_copy = getattr(self, 'params').copy()
                for kwarg_key, kwarg_val in kwargs[pos_key].items():
                    foo_copy[kwarg_key] = kwarg_val
                setattr(self, 'params', foo_copy)
            else:
                setattr(self, pos_key, pos_val)

    def glass_quest(self, index: str = None, endpoint: str = None, **kwargs):
        """
        See 'GlassClient.endpoint_helper' for available endpoints.

        * "index": str = ex.'indicators'
        * "endpoint": str = ex.'hash_ribbon'
        * "a": str = ex.'BTC'
        * "s": int = ISO-8601:[YYYY-MM-DD HH:MM]
        * "u": int = ISO-8601:[YYYY-MM-DD HH:MM]
        * "i": str = freq_interval(['1h', '24h', '10m', '1w', '1month'])
        * "f": str = format(['JSON', 'CSV'])
        * "c": str = currency(['NATIVE', 'USD'])
        * "e": str = ['aggregated','binance','bittrex','coinex','gate.io','huobi','poloniex']
        * "timestamp_format": str = 'unix'.try('humanized(RFC-3339)')
        * "api_key": str = autofill(see_base_class_attrs)

        :return: tuple('index_endpoint_asset', Response)
        """
        qc = locals().copy()
        if index and endpoint is not None:
            self._set_attributes(index=qc['index'], endpoint=qc['endpoint'])
        elif endpoint is not None:
            self._set_attributes(endpoint=qc['endpoint'])
        if len(qc['kwargs']) != 0:
            self._set_attributes(kwargs=qc['kwargs'])
        assert self.index and self.endpoint and self.params['a'] is not None, \
            "REQUIRED ATTRIBUTES are REQUIRED at some point. . ."
        return self.get_metrics(
            getattr(self, 'index'), getattr(self, 'endpoint'), **getattr(self, 'params'))


class Glassnodes(GlassClient):
    # Pandas.DataFrame Configuration
    pandas.set_option('display.width', 120)

    def __init__(self):
        super(Glassnodes, self).__init__()
        self._request_lock = RLock()
        self._responses = Queue()
        self._results_ready = Event()
        self._processed = []

    def _q_request(self, index: str, endpoint: str, **kwargs) -> None:
        """ Sends HTTP request to glassnode and puts raw response obj in FIFO queue """
        with self._request_lock:
            metric, data = self.glass_quest(index=index, endpoint=endpoint, **kwargs)
        self.reader_writer(metric, data)
        thread_json = Thread(name='JSN', target=self.json_to_df, args=(metric, data.json()), daemon=True)
        thread_json.start()

    def magic_metrics(self, queries: List[Tuple[str, str, Dict[str, Any]]], update=False):  # -> List:
        """ U.I. Layer, pass Tuple['idx', 'endpoint', Dict:[str(param), Any]] """
        for idx, ends, kwargs in queries:
            _target = f"{idx}_{ends}_{kwargs['a']}"
            try:
                if update:
                    raise OSError
                _saved = self.reader_writer(_target)
                json_frame = Thread(
                    name='LOAD_'+_target, target=self.json_to_df, args=(_target, _saved), daemon=True)
                json_frame.start()
            except OSError:
                _requester = Thread(
                    name='REQUEST_'+_target, target=self._q_request, args=(idx, ends), kwargs=kwargs)
                _requester.start()
        with self._request_lock:
            return self._processed

    def json_to_df(self, _metric, _data):
        # TODO timeit (git_implementation) vs (my_implementation)
        #  * df = pd.DataFrame(json.loads(r.text))
        #  * df = df.set_index('t')
        #  * df.index = pd.to_datetime(df.index, unit='s')
        #  * df = df.sort_index()
        #  * s = df.v
        #  * s.name = '_'.join(url.split('/')[-2:])
        #  * return s
        try:
            frame_keys = ['t'] + list(_data[0]['o'].keys())
            framed = pandas.DataFrame(
                data=[{k: (_data[iters]['t'] if k in 't' else _data[iters]['o'][k])
                       for k in frame_keys} for iters in range(len(_data))],
                columns=frame_keys)
        except KeyError:
            framed = pandas.DataFrame(_data)
        framed.set_index('t', inplace=True)
        framed.index = pandas.to_datetime(
            framed.index.to_flat_index(), unit='s', infer_datetime_format=True)
        framed.sort_index(inplace=True)
        framed.name = _metric
        self.print_processed(framed)  # [ Comment out to disable auto printing ]
        self._processed.append(framed)

    def get_processed(self):
        return self._processed

    @staticmethod
    def print_processed(ready) -> None:
        """ DataFrame pretty printer """
        _fat_line = ''.join(['-' for i in range(50)])
        _formatter = "{}\npandas.DataFrame -> {}\n\n{}\n\n{}\n{}"
        try:
            print(_formatter.format('\n'+_fat_line, ready.name, ready, ready.columns, _fat_line+'\n'))
        except AttributeError:
            for dp in ready:
                print(_formatter.format(_fat_line, dp.name, dp, dp.columns, _fat_line))

    @staticmethod
    def reader_writer(meter, dater=None, _save_dir: str = 'PSEUDO_BASE') -> Any:
        """  If a metric has been previously saved load save, else request metric """
        _metric = f"{_save_dir}/{'_'.join(meter.split('/')).upper()}.json"
        if dater:
            with open(file=_metric, mode='w') as filer:
                json.dump(dater.json(), filer)
        else:
            with open(file=_metric, mode='r') as filer:
                return json.loads(filer.readline())


def quick_helper(p=True, t=False, a=False) -> None:
    _quick_help = GlassBroker()
    for glassy in _quick_help.get_endpoints(path=p, tier=t, assets=a):
        print(glassy)


if __name__ == '__main__':
    logging.debug(f'>>> Initialized __ApeQuest__ as {__name__}\n')
    meters = [('market', 'price_usd_close', {'a': 'BTC'})]
    foos = Glassnodes()
    foos.magic_metrics(meters)


else:
    logging.debug(f'>>> Initialized __ApeQuest__ as {__name__}\n')


# TODO Why are below metrics restricted(status:403)?
#   * ('market', 'mvrv_less_155', {'a': "BTC"}),
#   * ('market', 'mvrv_more_155', {'a': "BTC"}),

# _non_standard_responses = (
#     'futures_funding_rate_perpetual_all',
#     'futures_volume_daily_sum_all',
#     'futures_volume_daily_perpetual_sum_all',
#     'futures_open_interest_sum_all',
#     'futures_open_interest_perpetual_sum_all',
#     'futures_open_interest_latest',
#     'futures_volume_daily_latest',
#     'balance_exchanges_all',
#     'balance_miners_all',
#     'supply_distribution_relative',
#     'exchanges_sum',
#     'exchanges_relative',
#     'exchanges_mean',
#     'hash_ribbon',
#     'difficulty_ribbon',
#     'spent_output_price_distribution_ath',
#     'spent_output_price_distribution_percent',
#     'cyd',
#     'cyd_supply_adjusted',
#     'cyd_account_based_supply_adjusted',
#     'cyd_account_based', 'cdd90_age_adjusted',
#     'cdd90_account_based_age_adjusted',
#     'stock_to_flow_ratio',
#     'utxo_realized_price_distribution_ath',
#     'utxo_realized_price_distribution_percent',
#     'soab',
#     'price_usd_ohlc',
#     'liquid_illiquid_sum',
#     'hodl_waves',
#     'rcap_hodl_waves',
#     'lth_sth_profit_loss_relative',
#     'transfers_volume_miners_to_exchanges_all',
#     'supply_distribution_relative'
# )
