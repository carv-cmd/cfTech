import os
from queue import LifoQueue, Queue
from _queue import Empty

import ciso8601
from requests import Request, Session
from dotenv import load_dotenv, find_dotenv

from MongoDatabase.Mongos import Any, Optional, Dict, Tuple, List
from MongoDatabase.Mongos import logging, datetime, Thread, Event, RLock
from MongoDatabase.Mongos import MongoBroker

load_dotenv(find_dotenv())

__all__ = [
    'Glassnodes',
    'LongHandler',
    'logging',
    'Thread',
    'Event',
    'Queue',
    'Optional',
    'Tuple',
    'Dict',
    'List',
    'Any'
]


class LongHandler:
    _MASK = 65536
    _DIVS, _LONGS, _MODIFY = '_divMask', '_divKeys', '_divModified'

    @staticmethod
    def ciso_handler(ts: str = None):
        """ Return UNIX equivalent of ISO-8601 timestamp. """
        if ts:
            return int(ciso8601.parse_datetime(ts).timestamp())

    @staticmethod
    def _fallback_encoding(_long_keys, _modify_json, _mask=_MASK, _d=_DIVS, _k=_LONGS, _m=_MODIFY) -> Dict:
        for elem in _modify_json:
            elem['t'] = elem['t']
            for key in (_nested for _nested in elem.keys() if _nested not in 't'):
                try:
                    elem[key] = divmod(elem[key], _mask)
                except TypeError:
                    for failed in _long_keys:
                        elem[key][failed] = divmod(elem[key][failed], _mask)
        return {_d: _mask, _k: _long_keys, _m: _modify_json}

    @staticmethod
    def _fallback_decoding(decoded, _d=_DIVS, _k=_LONGS, _m=_MODIFY) -> Dict:
        _mask, _long_ki, _decode = decoded['_DATA'][_d], decoded['_DATA'][_k], decoded['_DATA'][_m]
        for _elem in _decode:
            _elem['t'] = _elem['t']
            try:
                for _modifier in _long_ki:
                    _div_o, _mod_o = _elem['o'][_modifier]
                    _elem['o'][_modifier] = (_div_o * _mask) + _mod_o
            except KeyError:
                _div_v, _mod_v = _elem['v']
                _elem['v'] = (_div_v * _mask) + _mod_v
        return decoded

    def fallback_encoder(self, _json_decoded, _max_int64=9223372036854774783, scan_skip=1000):
        _data = _json_decoded[0].json()
        _sub_key = ('v' if 'v' in _data[0] else 'o')
        try:
            _failed = list(
                [dict(filter(lambda elem: elem[1] > _max_int64, _data[scan][_sub_key].items()))
                 for scan in range(0, len(_data), scan_skip)][-1:][0].keys()
            )
        except AttributeError:
            _failed = [_data[kth][_sub_key] for kth in range(0, len(_data), scan_skip)
                       if _data[kth][_sub_key] > _max_int64]
        if _failed:
            e_start = datetime.now()
            _data = self._fallback_encoding(_long_keys=_failed, _modify_json=_data)
            logging.info(f'* ENCODING.DURATION -> sec(<{(datetime.now() - e_start).total_seconds()}>)\n')
        return {'_metrics': _json_decoded[1], '_parameters': _json_decoded[2], '_data': _data}

    def fallback_decoder(self, _json_encoded) -> Dict:
        try:
            d_start = datetime.now()
            _deco = self._fallback_decoding(decoded=_json_encoded)
            logging.info(f'* DECODING.DURATION -> sec(<{(datetime.now() - d_start).total_seconds()}>)\n')
        except TypeError:
            return _json_encoded
        except KeyError:
            return _json_encoded


class _GlassBroker(LongHandler, MongoBroker):
    _GLASSNODE = "https://api.glassnode.com/v1/metrics"
    _HELPER = "https://api.glassnode.com/v2/metrics/endpoints"
    _API_KEY = os.getenv('GLASSNODE')

    __slots__ = ('_session',)

    def __init__(self, start=True, ip='127.0.0.1:27017', db='Glassnodes'):
        super(_GlassBroker, self).__init__(start=start, client_ip=ip, db_name=db)
        self._session = Session()

    def _request(self, req_method: str, target: str, params: Optional[Dict[str, Any]] = None) -> Tuple:
        """
        <GET> only method currently implemented. Handles all request.methods, I think?

        :param req_method: HTTP request method. Default(<GET>)
        :param target: Full api request endpoint. **constructed by caller
        :param params: Asset('a') required, all others autogenerated where needed

        :return: dict(key=request_endpoint, value=[asset_name, response.json])
        """
        assert 'a' in params, "minParams=('asset')"
        logging.info(f'* <Request@[ <{datetime.now()}> ] -> {target}')
        response = self._session.send(Request(
            method=req_method, url=target, params={**params, **{'api_key': self._API_KEY}}).prepare())
        response.close()
        _response_code = response.status_code
        logging.info(f'* <Response[ <{datetime.now()}> : ({response.reason} : {_response_code}) ]>\n')
        assert _response_code is 200, 'Response.status.reason -> checkLogs'
        return response, '_'.join(target.upper().split('/')[-2:]), params

    def get_metrics(self, index: str, endpoint: str, **kwargs) -> Tuple:
        # TODO assert endpoint in self._validity[index], f'{index}/{endpoint}->Invalid'
        """
        GET/Query -> https://api.glassnode.com/v1/metrics/<user>
        See _GlassClient.glass_quest docstring for all possible kwargs

        :param index: API endpoint, ex; index='indicators'
        :param endpoint: API endpoint, ex; endpoint='stock_to_flow_ratio'
        :param kwargs: {'a': AssetSymbol(required)}

        :return: tuple('index_endpoint_asset', Response)
        """
        return self._request('GET', target=f'{self._GLASSNODE}/{index}/{endpoint}', params=kwargs)

    def get_endpoints(self, specified: dict = None, updates=False) -> List:
        """
        :param specified: ex. { $and: [{"tier": 1}, {"assets.symbol": {"$eq": 'BTC'}}]}
        :param updates: if true, db.GlassPoints.drop, db.GlassPoints.insert(request); else db.loader
        :return: List[Dicts[endpoint_data]]
        """
        if updates:
            self.mongo_drop_collection('GlassPoints', check=updates)
            _recent = self._request('GET', target=self._HELPER, params={'a': '_null_'})
            self.mongo_insert_many(_recent[0].json(), col_name='GlassPoints')
        self.set_collection(collection_name='GlassPoints')
        if specified:
            _finder = self.working_col.find(specified)
        else:
            _finder = self.working_col.find()
        return list(_finder)


class _GlassClient(_GlassBroker):
    """
    * Parameters can be passed to class call or instance method.

    * Attributes stored across instances for easy subsequent requests.

    * See _GlassClient.glass_quest docstring for parameter details.

    * REQUIRED -> index: str, endpoint: str, asset_symbol['a']: str.

    * OPTIONAL -> kwargs: defaults applied on instance creation.

    * METRIC-TIMESTAMPS(utc) -> Always refer to start of interval.
    """

    __slots__ = (
        'a', 's', 'u', 'i', 'f', 'c', 'e', 'timestamp_format',
        'index', 'endpoint', 'params'
    )
    _PARAMS = __slots__[0: 8]

    def __init__(self, index=None, endpoint=None,
                 a=None, s=None, u=None, i='24h', f='JSON',
                 c=None, e=None, timestamp_format='unix'):
        super(_GlassClient, self).__init__()
        self.a = a            # asset_symbol
        self.s = s            # start_point
        self.u = u            # until_point
        self.i = i            # resolution_interval
        self.f = f            # response_format
        self.c = c            # currency
        self.e = e            # exchange_name
        self.timestamp_format = timestamp_format
        self.index = index
        self.endpoint = endpoint
        self.params = \
            {k: (self.ciso_handler(ve) if k in ('s', 'u') else ve)
             for k, ve in locals().copy().items() if k in self._PARAMS}

    def set_attributes(self, **kwargs):
        """ Set class attributes. _PRIVATE """
        foo_copy = getattr(self, 'params').copy()
        for pos_key, pos_val in kwargs.items():
            if pos_key in 'kwargs':
                for k_key, k_val in kwargs['kwargs'].items():
                    try:
                        foo_copy[k_key] = self.ciso_handler(k_val)
                    except ValueError:
                        foo_copy[k_key] = k_val
                setattr(self, 'params', dict(filter(lambda elem: elem[1] is not None, foo_copy.items())))
            else:
                setattr(self, pos_key, pos_val)

    def glass_quest(self, index: str = None, endpoint: str = None, **kwargs):
        """

        -- REQUEST PARAMETERS --
         * "index": str = ex.'indicators'
         * "endpoint": str = ex.'hash_ribbon'
         * "a": str = ex.'BTC'
         * "s": int = ISO-8601:[YYYY-MM-DD HH:MM] (examples below)
         * "u": int = ISO-8601:[YYYY-MM-DD HH:MM] (examples below)
         * "i": str = freq_interval(['1h', '24h', '10m', '1w', '1month'])
         * "f": str = format(['JSON', 'CSV'])
         * "c": str = currency(['NATIVE', 'USD'])
         * "e": str = ['aggregated','binance','bittrex','coinex','gate.io','huobi','poloniex']
         * "timestamp_format": str = 'unix'.try('humanized(RFC-3339)')
         * "api_key": str = autofill(see_base_class_attrs)

        -- TIMESTAMP EXAMPLES FOR START/UNTIL INTERVALS --

         * Monthly resolution: 2019-05-01
           -> 2019-05-01 00:00 UTC to 2019-05-31 23:59 UTC (May 2019)

         * Weekly resolution: 2019-05-13
           -> 2019-05-13 00:00 UTC to 2019-05-19 23:59 UTC (Week 20)

         * Daily resolution: 2019-05-13
           -> 2019-05-13 00:00 UTC to 2019-05-13 23:59 UTC

         * Hourly resolution: 2019-05-13 10:00 UTC
           -> 2019-05-13 10:00 UTC to 2019-05-13 10:59 UTC

         * 10 Min resolution: 2019-05-13 10:20 UTC
           -> 2019-05-13 10:20 UTC to 2019-05-13 10:29 UTC

        :return: tuple('index_endpoint_asset', Response)
        """
        qc = locals().copy()
        if index and endpoint is not None:
            self.set_attributes(index=qc['index'], endpoint=qc['endpoint'])
        elif endpoint is not None:
            self.set_attributes(endpoint=qc['endpoint'])
        if any(qc['kwargs']):
            self.set_attributes(kwargs=qc['kwargs'])
        assert self.index and self.endpoint and self.params['a'] is not None, \
            "REQUIRED ATTRIBUTES are REQUIRED at some point. . ."
        return self.get_metrics(
            getattr(self, 'index'), getattr(self, 'endpoint'), **getattr(self, 'params'))


class Glassnodes(_GlassClient, LongHandler, MongoBroker):

    __slots__ = ('_response_recv', '_mon_locker', '_queued', '_loaded')

    def __init__(self):
        super(Glassnodes, self).__init__()
        self._response_recv = Event()
        self._mon_locker = RLock()
        self._queued = LifoQueue()
        self._loaded = []

    def _mongo_reader(self, q_filter):
        if 'i' not in q_filter:
            q_filter[2]['i'] = self.params['i']
        self.set_collection(collection_name=f"{q_filter[2]['a']}_{q_filter[2]['i']}".upper())
        _load_cursor = self.mongo_query(
            user_defined={'_metrics': {'$eq': f'{q_filter[0]}_{q_filter[1]}'.upper()}})
        try:
            return _load_cursor[0]
        except IndexError:
            raise AssertionError('Query Cursor Empty')

    def _mongo_writer(self):
        while True:
            try:
                self._response_recv.wait(timeout=6)
                _dox = self._queued.get_nowait()
                self.mongo_insert_one(
                    one_dump=_dox, col_name=f"{_dox[2]['a']}_{_dox[2]['i']}".upper())
                self._loaded.append(self.mongo_query({'_metrics': {'$eq': _dox[1]}}))
                self._queued.task_done()
            except Empty:
                self._queued.all_tasks_done = True
                break

    def _requester(self, writer: Thread, queries: Tuple[str, str, Dict[str, Any]]):
        """ U.I. Layer, pass Tuple['idx', 'endpoint', Dict:[str(param), Any]] """
        with self._mon_locker:
            self._queued.put(self.glass_quest(index=queries[0], endpoint=queries[1], **queries[2]))
        try:
            writer.start()
        except RuntimeError:
            pass
        self._response_recv.set()
        self._response_recv.clear()

    def magic_metrics(self, big_query: List[Tuple[str, str, Dict[str, Any]]]):
        _mon_writes = Thread(name='_MONGO_WRITER', target=self._mongo_writer)
        for query in big_query:
            try:
                self._loaded.append(self._mongo_reader(query))
            except AssertionError:
                _requester = Thread(
                    name="REQUESTING", target=self._requester, args=(_mon_writes, query,), daemon=True)
                _requester.start()
        with self._mon_locker:
            self._response_recv.set()
            self._queued.join()
            self.kill_client()


if __name__ == '__main__':
    # for i in range(10):
    #     glasses.fallback_encoder(_jazzy)
    #
    # _jaz = _jazzy[0].json()
    # print(f'\n>>> Conversions Array Length: {len(_jaz)}')
    # print(f"Initial: {_jaz[2500]['o']}")
    # print(f"Encoded: {glasses.fallback_encoder(_jazzy)['_data']['_divModified'][2500]['o']}")
    pass


else:
    logging.debug(f'>>> Initialized {__name__} @ <{datetime.now()}>\n')
