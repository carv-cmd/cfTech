import json
import time
from datetime import datetime
from threading import Thread, Event, Lock
from threading import enumerate as enumerate_threads

from FTX_ws_Client import FtxWebsocketClient, Optional, Dict


class StreamWizard(FtxWebsocketClient):
    def __init__(self):
        super().__init__()
        self._locks = Lock()
        self._run_event = Event()
        self._initialize: Dict()

    @staticmethod
    def _curr_time(market):
        return datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')

    def _data_wizard(self,
                     orderbooks: Optional[float] = None,
                     tickers: Optional[float] = None,
                     trades: Optional[float] = None):
        self._initialize = dict(
            orderbook=[orderbooks, self.get_orderbook, self.get_orderbook_timestamp],
            ticker=[tickers, self.get_ticker, self.get_ticker_timestamp],
            trade=[trades, self.get_trades, self._curr_time]
        )

    def _stream_writer(self, polling_channel: str, time_series_data: list):
        self._locks.acquire()
        print(f'\n* I/O.WRITE({polling_channel}).LOCKED = {self._locks.locked()}')
        try:
            if not time_series_data[1]:
                raise ValueError(f'>>> SKIPPED_WRITE_TIME[<{time_series_data[0]}>')
            with open(f'../temp_storage/{polling_channel}.txt', mode='a') as file_obj:
                file_obj.writelines(
                    f"{json.dumps({f'REFRESH_{polling_channel}': time_series_data[0]})}\n"
                    f"{json.dumps({f'UPDATED': time_series_data[1]})}\n")
        except Exception as exc:
            print(f'\n*** <<I/O_BREAK:[ {polling_channel} ] -> {exc} ')
            raise
        finally:
            self._locks.release()
            print(f'\n** I/O_PASS({polling_channel}).LOCKED = {self._locks.locked()}')
            return

    def _poll_manager(self, func, ts, market, stream, delay):
        file_name = ''.join(['_' if x in '/' else x for x in market]).upper()
        while self._run_event.is_set():
            time.sleep(delay)
            write_threader = Thread(
                target=self._stream_writer,
                args=(f'{stream.upper()}_{file_name}',
                      [ts(market.upper()), func(market.upper())])
            )
            write_threader.start()

    def data_wizard(self, market: str, *,
                    orderbook: Optional[float] = None,
                    ticker: Optional[float] = None,
                    trade: Optional[float] = None):
        self._data_wizard(orderbooks=orderbook, tickers=ticker, trades=trade)
        self._run_event.set()
        halter = []
        for stream, subs in self._initialize.items():
            if subs[0] is not None:
                func, ts, delay = subs[1], subs[2], subs[0]
                polling_thread = Thread(target=self._poll_manager,
                                        args=(func, ts, market, stream, delay))
                polling_thread.start()
                halter.append(polling_thread)
                time.sleep(0.5)
        try:
            while 1:
                time.sleep(1)
        except KeyboardInterrupt:
            print(f'\n> Attempt -> Terminate_All_Active_Threads[ {enumerate_threads()} ]')
            self._run_event.clear()
            for stopper in halter:
                stopper.join()
                print(f'\n>> Thread(<name[{stopper.name}]>:<id[{stopper.ident}]>).isAlive '
                      f'= {stopper.is_alive() is False}')
                time.sleep(0.5)
        finally:
            print('>>>> Terminated_All_Polling_Threads -> raising SystemExit')
            self.disconnect()
        return


if __name__ == '__main__':
    ftx = StreamWizard()
    ftx.data_wizard('BTC-PERP', orderbook=0.25, ticker=1, trade=4)
